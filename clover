#!/usr/bin/env python
"""
usage: [-h] <command> [<config> <vm_name>]

commands:
    converge            bootstraps virtual machine and applies playbook
    destroy             destroys virtual machine
    status              checks status of virtual machine
    verify              runs one of the verifiers against the virtual machine
    ssh                 ssh into virtual machine
"""
import yaml, vagrant, os, subprocess, shutil, re
from jinja2 import Template
from docopt import docopt

CONFIG_FILE_REGEX = r'\.?([a-zA-Z0-9\-]+)\.yml'
VAGRANT_TEMPLATE = '''Vagrant.configure("2") do |config|
    {% for node in config.nodes %}
    config.vm.define "{{ node.name }}" do |{{ node.name }}|
        {{ node.name }}.vm.box = "{{ node.provider.box }}"
    {%- if node.provider.network %}
    {%- for forwarded_port in node.provider.network.forwarded_port %}
        {{ node.name }}.vm.network "forwarded_port", guest: {{ forwarded_port.split(':')[0] }}, host: {{ forwarded_port.split(':')[1] }}, port: "{{ forwarded_port.split(':')[2] }}"
    {% endfor -%}
    {% endif %}
        {{ node.name }}.vm.synced_folder ".", "/vagrant", disabled: true
    {%- for host_path, vm_path in synced_folders[node['name']].items() %}
        {{ node.name }}.vm.synced_folder "{{ host_path }}", "{{ vm_path }}"
    {%- endfor %}
    {% if node.provisioner.name == 'ansible-local' %}
        {{ node.name }}.vm.provision "shell", inline: <<-SHELL
            rpm -q ansible || (yum install -y ansible; echo "localhost ansible_connection=local" > /etc/ansible/hosts)
        SHELL
    {% endif %}
        {{ node.name }}.vm.provision "shell", inline: <<-SHELL
    {% if node.provisioner.vars %}
            cp {{ node.provisioner.vars.path }} /etc/ansible/vars.yml
    {% endif %}
    {%- if node.provisioner.shell %}
            {{ node.provisioner.shell }}
    {% else %}
            ansible-playbook {{ node.provisioner.playbook }}
    {% endif %}
        SHELL
    end
    {% endfor %}
end
'''


def get_synced_folders(config):
    '''converts host_path:vm_path into dictionary with absolute paths'''
    synced_folders_dict = {}

    for node in config['nodes']:
        synced_folders_dict[node['name']] = {}
        synced_folders = node['provider'].get('synced_folders')
        if synced_folders:
            for sf in synced_folders:
                host_path, vm_path = sf.split(':')

                if not os.path.isabs(vm_path):
                    exit(f'Path inside vm "{vm_path}" must be absolute in synced folder "{sf}", exiting.')

                if os.path.isabs(host_path):
                    synced_folders_dict[node['name']][host_path] = vm_path
                else:
                    if host_path.startswith('~'):
                        host_path = os.path.abspath(os.path.expanduser(host_path))
                    else:
                        host_path = os.path.abspath(os.path.join('..', host_path))
                    synced_folders_dict[node['name']][host_path] = vm_path

    return synced_folders_dict


def generate_vagrant_config(config):
    '''generate Vagrantfile based on config'''
    rendered_config = Template(VAGRANT_TEMPLATE).render(config=config, synced_folders=get_synced_folders(config))
    with open('Vagrantfile', 'w') as f:
        f.write(rendered_config)


def get_status(vms, vagrant_dir, vm=None):
    if os.path.exists(vagrant_dir):
        os.chdir(vagrant_dir)
        if os.path.exists('Vagrantfile'):
            v = vagrant.Vagrant()
            if vm:
                state = v.status(vm_name=vm)
            else:
                state = v.status()
        else:
            state = None
        os.chdir('..')
        return state
    else:
        return None


def ssh_command(vagrant, vm_name, command):
    return vagrant._run_vagrant_command(['ssh', vm_name, '--', '-t'] + command.split())


def main(config_file):
    if not config_file:
        config_file = '.clover.yml'

    if not os.path.exists(config_file) and config_file != '.clover.yml':
        config_file += '.yml'

    try:
        with open(config_file, 'r') as f:
            config = yaml.load(f)
    except FileNotFoundError:
        exit(f'ERROR: configuration file {config_file} was not found')
    except:
        exit('ERROR: failed to load configuration file, syntax error')

    vagrant_dir = '.' + re.search(CONFIG_FILE_REGEX, config_file).groups()[0]

    if vm_name:
        vms = [vm_name]
    else:
        vms = list(map(lambda x: x['name'], config['nodes']))

    if command == 'status':
        state = get_status(vms, vagrant_dir)
        for vm in vms:
            if state:
                vm_state = list(filter(lambda x: x[0] == vm, state))[0][1]
                print(f'{vm}:\t{vm_state}')
            else:
                print(f'{vm}:\tnot_running')
        return

    elif command == 'converge':
        if get_status(vms, vagrant_dir):
            os.chdir(vagrant_dir)
            v = vagrant.Vagrant()
            for vm in vms:
                run = v._stream_vagrant_command(['provision', vm])
                with open('clover.log', 'a') as log:
                    log.write(f'Converging {vm}:\n')
                    for line in run:
                        log.write(line)
                        print(line, end='')
        else:
            os.mkdir(vagrant_dir)
            os.chdir(vagrant_dir)
            generate_vagrant_config(config)
            v = vagrant.Vagrant()
            for vm in vms:
                run = v.up(stream_output=True, vm_name=vm)

                with open('clover.log', 'a') as log:
                    log.write(f'Converging {vm}:\n')
                    for line in run:
                        log.write(line)
                        print(line, end='')

    elif command == 'destroy':
        state = get_status(vms, vagrant_dir)
        if state:
            os.chdir(vagrant_dir)
            v = vagrant.Vagrant()
            for vm in vms:
                try:
                    print(f'{vm}\tdestroyed')
                    v.destroy(vm_name=vm)
                except subprocess.CalledProcessError:
                    pass
            os.chdir('..')
        else:
            for vm in vms:
                print(f'{vm}\tnot_running')

        shutil.rmtree(vagrant_dir, ignore_errors=True)

    elif command == 'verify':
        state = get_status(vms, vagrant_dir)
        if not state:
            for vm in vms:
                exit(f'{vm}:\tnot_running')

        os.chdir(vagrant_dir)
        v = vagrant.Vagrant()

        for vm in vms:
            vm_config = list(filter(lambda x: x['name'] == vm, config['nodes']))[0]
            if vm_config['verifier']['name'] == 'goss':
                if not 'goss_file' in vm_config['verifier']:
                    exit(f'Please specify "goss_file" for goss verifier for node {vm}')

                print(f'Verifying {vm} with goss..')
                try:
                    ssh_command(v, vm, '/tmp/goss')
                except subprocess.CalledProcessError:
                    ssh_command(v, vm, 'curl -L https://github.com/aelsabbahy/goss/releases/download/v0.3.5/goss-linux-amd64 -o /tmp/goss')
                    ssh_command(v, vm, 'chmod +x /tmp/goss')

                print(subprocess.call(
                    f'vagrant ssh {vm} -- /tmp/goss -g {vm_config["verifier"]["goss_file"]} validate',
                    shell=True
                    ))
            else:
                exit(f'Verifier {vm_config["verifier"]["name"]} is not supported.')

    elif command == 'ssh':
        if len(vms) > 1:
            exit('Please specify vm name')

        vm = vms[0]
        state = get_status(vm, vagrant_dir)
        if state[0][1] == 'running':
            os.chdir(vagrant_dir)
            v = vagrant.Vagrant()
            ssh_config = v.conf(vm_name=vm)
            subprocess.call(f'ssh -p {ssh_config["Port"]} -i {ssh_config["IdentityFile"]} -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null {ssh_config["User"]}@{ssh_config["HostName"]}', shell=True)
        else:
            exit(f'{vm}:\tnot running')


if __name__ == '__main__':
    args = docopt(__doc__)
    command = args['<command>']
    vm_name = args['<vm_name>']
    config_file = args['<config>']
    main(config_file)
